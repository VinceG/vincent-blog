---
title: "PHP 5.3 Late Static Bindings"
date: 2010-10-12 15:25:10
categories: 
- "PHP"
- "php 5.3"
- "חדשות"
- "כללי"
tags: 
- "bindings"
- "late"
- "late static bindings"
- "PHP"
- "php 5.3"
- "php 5.3 late static bindings"
- "php5.3"
- "static"
- "static bindings"
---

PHP 5.3 כבר הציגה את עצמה ואת האפשרויות החדשות שהתווספו, אך בין כל האפשרויות שכבר עברנו עליהם ישנה עוד אפשרות אחת שהיא לא פחות חשובה, ויש צורך לעבור ולסקר גם אותה. האפשרות הזו היא <em>Late Static Binding</em>, שבתרגום חופשי זה 'כבילה מאוחרת' (למתודות/מאפיינים סטטיות/סטטיים), ופשוטו כמשמעו מאפשר  לרתום או לקשור מתודה או מאפיין סטטי לאחר הקמפול של הקוד.

<!--more-->הבעיה נובעת מהצורה בה מחלקות ב PHP מתייחסות אל עצמם, מילות מפתח כמו <em>self</em> הם מפוענחות בזמן הקומפילציה של הקוד ולא בזמן הרצה, ולכן זה אומר שמחלקות אשר יורשות ממחלקות אחרות, self תמיד יהיה מפוענח למחלקה בה הוא נמצא ולא במחלקה היורשת. ישנם הרבה מחלקות אשר מכילות פונקציונליות זהה בין המחלקות אך דורשות איזשהי תודעה של "באיזו מחלקה אני נמצא כרגע?", בין אם זה לגשת למתודות המוגדרות במחלקה או למאפיינים בה כדי שהמתודה המוגדרת במחלקת האב תיהיה נגישה בכל המחלקות היורשות ממנה. ללא <em>Late Static Binding</em>, זה תמיד יפוענח למחלקה שהכריזה על המשתנה/מתודה, שמשאיר את הברירה למפתחים שנאלצים לבחור בין להעתיק/להדביק את אותה הפונקציה/מתודה עבור כל מחלקה שדורשת זאת או להפוך את המתודה הסטטית שלהם לאחת דינאמית, מאחר ו <em>this$</em> מפענח את זה תמיד כמו שצריך.

אני חושב שזה יהיה יותר ברור אם נציג דוגמא לכך. בדוגמא הבאה ישנה מחלקה בשם Base, אשר כל המחלקות הנוספות יורשות ממנה (לצורך הדוגמא):

```
class Base {

protected static $tableName = 'base';

public static function getTableName() {
return self::$tableName;
}
}
```

כעת כשיש לי את מחלקת הבסיס שלי, אני מוכן להתחיל לעבוד ולכתוב את המחלקות הנוספות אשר יורשות ממחלקה זו, אני אתחיל בזה שאני אכתוב מחלקה אשר מטפלת במשתמשים שלי, אקרא לה Users, אני אגדיר רק את המאפיין של שם הטבלה מאחר והיא משתמשת באותה המתודה (<em>getTableName</em>) של החזרה שם הטבלה, הטבלה שיצרתי תראה כך:

```
class Users extends Base {

protected static $tableName = 'users';

}
```

כעת, בעת הקריאה למתודה getTableName זה התוצאה שאני אקבל:

```
Users::getTableName();  // returns "base"
```

כמובן זה לא מה שאני ציפיתי או רציתי לקבל, אבל זה מה ש PHP נתן לי ויכול לתת. עד לגרסא 5.3, כעת אם נכניס לפעולה את  <em>Late Static Binding</em> אנו נכתוב את המחלקה הבסיס שוב פעם בצורה הבאה:

```
class Base {

protected static $tableName = 'base';

public static function getTableName() {
return static::$tableName;
}
}
```

(שימו לב לשינוי בין self ל static).

כעת כשנריך את הקוד שוב פעם נקבל את התוצאה הרצויה:

```
Users::getTableName(); // returns "users"
```

שינוי זה אומנם נראה לא כל כך משמעותי, אבל הוא מאפשר עכשיו יותר נגישות והתאמה אישית בין המחלקות, בנוסף לכל הוא יאפשר להדק את המחלקות שאנו נכתוב אף יותר ולחסוך את כל המתודות המיותרות שהיינו צריכים לשכפל בין המחלקות כי לא יכלנו לגשת למאפיינים של המחלקה אשר יורשת.
